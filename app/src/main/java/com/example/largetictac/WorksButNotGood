package com.example.largetictac;


import java.util.ArrayList;
import java.util.Random;

public class Model {
    public static final int EMPTY = 0;
    public static final int PLAYER_X = 1;
    public static final int PLAYER_O = -1;

    private int[][] board;
    private int currentPlayer = -1;

    public Model() {
        board = new int[15][15];
        currentPlayer = PLAYER_X;
    }

    public int getCurrentPlayer() {
        return currentPlayer;
    }

    public boolean isLegal(int row, int col) {
        return board[row][col] == EMPTY;
    }

    public boolean makeMove(int row, int col) {
        if (!isLegal(row, col)) return false;
        board[row][col] = currentPlayer;
        return true;
    }

    public void changePlayer() {
        currentPlayer *=-1;
    }


    public int checkWin(int row, int col) {
        int player = board[row][col];  // The player who placed this piece
        if (player == EMPTY) return EMPTY;

        // Directions: vertical, horizontal, diagonal ↘, anti-diagonal ↙
        int[][] directions = {
                {1, 0},   // vertical
                {0, 1},   // horizontal
                {1, 1},   // main diagonal
                {1, -1}   // anti-diagonal
        };

        for (int[] dir : directions) {
            int dr = dir[0], dc = dir[1];
            int count = 1; // count the current stone

            // go forward
            for (int step = 1; step < 5; step++) {
                int r = row + dr * step;
                int c = col + dc * step;
                if (r < 0 || r > 14 || c < 0 || c > 14) break;
                if (board[r][c] == player) count++;
                else break;
            }

            // go backward
            for (int step = 1; step < 5; step++) {
                int r = row - dr * step;
                int c = col - dc * step;
                if (r < 0 || r > 14 || c < 0 || c > 14) break;
                if (board[r][c] == player) count++;
                else break;
            }

            if (count >= 5) return player; // Winner found!
        }

        return EMPTY; // No winner
    }
    public int NumCheckWin(int row, int col, int length) {//Need to check if winning set is impossible because of the walls
        int player = board[row][col];
        if (player == EMPTY) return EMPTY;

        int[][] directions = {
                {1,0}, {0,1}, {1,1}, {1,-1}
        };

        for (int[] d : directions) {
            int dr = d[0], dc = d[1];

            int forward = 0;
            int r = row + dr, c = col + dc;

            while (r >= 0 && r < 15 && c >= 0 && c < 15 && board[r][c] == player) {
                forward++;
                r += dr;
                c += dc;
            }

            int backward = 0;
            r = row - dr;
            c = col - dc;

            while (r >= 0 && r < 15 && c >= 0 && c < 15 && board[r][c] == player) {
                backward++;
                r -= dr;
                c -= dc;
            }

            if (forward + backward + 1 >= length) return player;
        }

        return EMPTY;
    }







    public boolean isTie() {
        // If all cells filled and no winner
        for(int i = 0;i<15;i++){
            for(int j = 0; j<15;j++){
                if(board[i][j]==0) return false;
            }
        }
        return true;
    }

    public void resetGame() {
        for (int i = 0; i < 15; i++) {
            for (int j = 0; j < 15; j++) {
                board[i][j] = EMPTY;
            }
        }
        currentPlayer = PLAYER_X;
    }

    public ArrayList<Move> getPossibleMoves() {
        ArrayList<Move> moves = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            for (int j = 0; j < 15; j++) {
                if (board[i][j] == EMPTY) {
                    moves.add(new Move(i, j));
                }
            }
        }
        return moves;
    }

    public int getNumOfAdjacentSlots(int row, int col) {
        int sum = 0;
        for (int R = row - 1; R <= row + 1; R++) {
            for (int C = col - 1; C <= col + 1; C++) {
                if (R < 0 || R > 14 || C < 0 || C > 14) continue;
                if (R == row && C == col) continue;
                if (board[R][C] != EMPTY) sum++;
            }
        }
        return sum;
    }
    public ArrayList<Move> getPossibleAdjacentMoves() {
        ArrayList<Move> moves = new ArrayList<>();
        for (int i = 0; i < 15; i++) {
            for (int j = 0; j < 15; j++) {
                if (board[i][j] == EMPTY && getNumOfAdjacentSlots(i,j)>0) {
                    moves.add(new Move(i, j));
                }
            }
        }
        return moves;


    }
    public Move getRandomMove() {
        ArrayList<Move> moves = getPossibleAdjacentMoves();
        if (moves.isEmpty()) return null; // No moves left
        Random rand = new Random();
        return moves.get(rand.nextInt(moves.size()));
    }

    public Move getHeuristicMove(int aiPlayer, int humanPlayer) {
        // Check for wins in depth of 5-2
        for(int depth = 5;depth>1;depth--){
            // 3.Make a winning situation
            for (Move move : getPossibleAdjacentMoves()) {
                board[move.row][move.col] = aiPlayer;
                if (NumCheckWin(move.row, move.col,depth) == aiPlayer) {
                    board[move.row][move.col] = EMPTY;
                    return move;
                }
                board[move.row][move.col] = EMPTY;
            }
            // 4. Block if needed
            for (Move move : getPossibleAdjacentMoves()) {
                board[move.row][move.col] = humanPlayer;
                if (NumCheckWin(move.row, move.col,depth) == humanPlayer) {
                    board[move.row][move.col] = EMPTY;
                    return move;
                }
                board[move.row][move.col] = EMPTY;
            }

        }
    return null;
    }


}
